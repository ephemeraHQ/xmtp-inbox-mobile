import PushNotificationIOS from '@react-native-community/push-notification-ios';
import {Client, XMTPPush} from '@xmtp/react-native-sdk';
import RNPush from 'react-native-push-notification';
import {AppConfig} from '../consts/AppConfig';
import {SupportedContentTypes} from '../consts/ContentTypes';
import {
  CHANNEL_ID,
  CHANNEL_NAME,
  PUSH_SERVER,
} from '../consts/PushNotifications';

export class PushNotifications {
  client: Client<SupportedContentTypes>;
  pushClient: XMTPPush;

  constructor(client: Client<SupportedContentTypes>) {
    this.client = client;
    this.pushClient = new XMTPPush(client);
    RNPush.configure({
      async onRegister(registrationData) {
        try {
          const token = registrationData.token;
          console.log('PUSH NOTIFICATION TOKEN:', token);
          if (AppConfig.PUSH_NOTIFICATIONS) {
            XMTPPush.register(PUSH_SERVER, token);
          }
        } catch (error) {
          console.error(
            'PUSH NOTIFICATION Failed to register push token:',
            error,
          );
        }
      },
      onRegistrationError(error) {
        console.log('PUSH NOTIFICATION Failed to register push token:', error);
      },
      onAction(notification) {
        console.log('PUSH NOTIFICATION ACTION:', notification.action);
      },
      onRemoteFetch(notification) {
        console.log('PUSH NOTIFICATION REMOTE FETCH:', notification);
      },
      onNotification(notification) {
        console.log('PUSH NOTIFICATION NOTIFICATION:', notification);
        const encryptedMessage = notification.data.encryptedMessage;
        const topic = notification.data.topic;

        if (encryptedMessage == null || topic == null) {
          return;
        }
        // (async () => {
        //   const conversations = await client.conversations.list();
        //   const conversation = conversations.find(
        //     (c: {topic: string}) => c.topic === topic,
        //   );
        //   if (conversation == null) {
        //     return;
        //   }

        //   const peerAddress = conversation.peerAddress;
        //   const decodedMessage = await conversation.decodeMessage(
        //     encryptedMessage,
        //   );
        //   const body = decodedMessage.content;

        //   PushNotification.localNotification({
        //     /* Android Only Properties */
        //     channelId: 'xmtp-react-native-example-dm', // (required) channelId, if the channel doesn't exist, notification will not trigger.
        //     messageId: 'google:message_id', // (optional) added as `message_id` to intent extras so opening push notification can find data stored by @react-native-firebase/messaging module.

        //     /* iOS only properties */
        //     category: '', // (optional) default: empty string
        //     subtitle: 'My Notification Subtitle', // (optional) smaller title below notification title

        //     /* iOS and Android properties */
        //     id: 0, // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
        //     title: peerAddress, // (optional)
        //     message: body, // (required)
        //   });
        // })().catch(console.error);

        // process the notification here
        // required on iOS only
        notification.finish(PushNotificationIOS?.FetchResult.NoData);
      },

      // Android only
      // senderID: 'YOUR_FIREBASE_SENDER_ID',
      // iOS only
      permissions: {
        alert: true,
        badge: true,
        sound: true,
      },
      popInitialNotification: true,
      requestPermissions: true,
    });
  }

  subscribeToAllGroups = async () => {
    const client = this.client;
    await Promise.all([
      client.contacts.refreshConsentList(),
      client.conversations.syncGroups(),
    ]);
    const groups = await client.conversations.listGroups();
    const topics = groups.map(c => c.topic);
    const allowedTopics: string[] = [];

    await Promise.allSettled(
      groups.map(group =>
        client.contacts.isGroupAllowed(group.topic).then(allowed => {
          if (!AppConfig.GROUP_CONSENT || allowed) {
            allowedTopics.push(group.topic);
          }
        }),
      ),
    );
    console.log('PUSH NOTIFICATION TOPICS:', topics);
    this.subscribeToGroups(allowedTopics);
  };

  subscribeToGroups = async (topics: string[]) => {
    if (topics.length === 0) {
      return;
    }
    if (AppConfig.PUSH_NOTIFICATIONS) {
      await this.pushClient.subscribe(topics);
    }
    for (const topic of topics) {
      RNPush.createChannel(
        {
          channelId: CHANNEL_ID + topic, // (required)
          channelName: CHANNEL_NAME + topic, // (required)
        },
        created =>
          console.log(`PUSH NOTIFICATION createChannel returned '${created}'`),
      );
    }
  };

  subscribeToGroup = async (topic: string) => {
    return this.subscribeToGroups([topic]);
  };
}
